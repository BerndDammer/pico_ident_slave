// oc_rx.pio

.program oc_rx
.side_set 1

; PINDIRS is the pin for setting the input direction (used for setting line to high-Z)
; DATA_PIN is the pin for reading the data (GPIO 22 in this case)

public entry:
    ; Wait for the first start bit (line goes low)
    wait 0 pin 0       ; Wait for the input pin to be low (1st Start Bit)

    ; Delay for 1.5 bit times to align to the middle of the next bit
    set x, 13 [1]
    jmp x-- continue   [1]
continue:

.wrap_target
    ; Clocking in all 14 bits (4 start, 8 data, 2 stop)
    in pins, 1         ; Read one bit from the input pin (data_pin)

    ; Total 14 bits. We only care about bits 5-12 (the data).
    ; We can discard the rest by using 'y' or 'x' as counters.
    ; This is a simplified approach: clock in 14 times and discard the 6 non-data bits.

    set x, 13          ; Total of 14 bits to read (0 to 13)
loop_read:
    in pins, 1         [1] ; Read 1 bit, takes 2 cycles (with delay)
    jmp x-- loop_read

    ; After 14 bits, the 8 data bits are in the ISR.
    push block
.wrap

// oc_tx.pio

.program oc_tx
.side_set 1

; DATA_PIN is the single I/O pin (GPIO 22).
; Data is output LSB first.

.wrap_target
    pull block         ; Wait for data from the TX FIFO

    ; Set up the output pin for transmitting (set dir to out)
    set pindirs, 1     side 0 [1] ; side 0: output low (Start bit)

    ; 4 Start Bits (all low)
    set x, 3           ; 4 cycles total (0 to 3)
start_loop:
    out null, 1        side 0 [1] ; Output low (takes 2 cycles)
    jmp x-- start_loop

    ; 8 Data Bits (LSB first)
    set x, 7           ; 8 cycles total (0 to 7)
data_loop:
    out pins, 1        side 1 [1] ; Output data bit, then set to high (open collector)
    jmp x-- data_loop

    ; 2 Stop Bits (all high/open-collector)
    set x, 1           ; 2 cycles total (0 to 1)
stop_loop:
    out null, 1        side 1 [1] ; Output high (open collector, takes 2 cycles)
    jmp x-- stop_loop

    ; Set back to input direction for RX (High-Z)
    set pindirs, 0     side 1 [1]

.wrap
